#include <Adafruit_NeoPixel.h>
Adafruit_NeoPixel strip = Adafruit_NeoPixel(64, 15, NEO_GRB + NEO_KHZ800);
/*the display has leds in sequence in a snake pattern, which is changed to x,y coords from 0 to 7 with
  the led[] array, then to read the position it takes the row + 8*column. x,y coords are stored in body */
const int buttons[2][2] = {{14, 16}, {5, 4}}; //[player 1 buttons][player 2 buttons] {{rb1, lb1},{rb2,lb2}}
const int led1 = 0, led2 = 12; //player 1 and 2 win leds
byte locks[2]; //direction change locks for both players (could probably go in properties)
int props[2][3]; //{{dir1, change1, length 1}, {dir2, change2, length 2}}
int body [2][16][2]; //[player], [segment], [coords(r,c)]
const static int bodystart[2][16][2] = {{{5, 7}}, {{2, 0}}}; //player 1 starts at (5,7)
const static int propsstart[2][3] = {{3, 0, 3}, {1, 0, 3}}; //both players have 3 length, player 1 is traveling in the 3 direction, player 2 in 1
int flipper[2][16][2];
int timedraw = 200, needfood = 1, food = 0, w;
byte led[64] = {0, 1, 2, 3, 4, 5, 6, 7, 15, 14, 13, 12, 11, 10, 9, 8, 16, 17, 18, 19, 20, 21, 22, 23, 31, 30, 29, 28, 27, 26, 25, 24, 32,
                33, 34, 35, 36, 37, 38, 39, 47, 46, 45, 44, 43, 42, 41, 40, 48, 49, 50, 51, 52, 53, 54, 55, 63, 62, 61, 60, 59, 58, 57, 56
               }; //array the swaps every other row of the matrix to create an x y plane instead of snake pattern

void resetbodies() { //set bodies and properties to their starting position arrays
  for (int i = 0; i < 2; i++) { //for both players
    for (int j = 0; j < 16; j++) { //for all segments
      for (int k = 0; k < 2; k++) { //for both coordinates
        body[i][j][k] = bodystart[i][j][k]; //set the data to the start data
      }
    }
    for (int m = 0; m < 3; m++) { //for all properties
      props[i][m] = propsstart[i][m];//set properties to starting properties
    }
  }
}

void setup() {
  resetbodies(); //set the bodies and properties to their game start values
  pinMode (led1, OUTPUT); //player 1 win led
  pinMode (led2, OUTPUT); //player 2 win led
  for (int i = 0; i < 2; i++) { //for both players
    for (int j = 0; j < 2; j++) { //for both buttons
      pinMode (buttons[i][j], INPUT); //set pinmode input to the button entry
    }
  }
  strip.begin(); //begin led strip
  strip.show();  // initialize all pixels to 'off'
  for (int i = 0; i < 2; i++) { //for both players
    strip.setPixelColor(led[body[i][0][0] + body[i][0][1] * 8], 100 - (100 * i), 0, 255 * i); //set the first pixel on, with color depending on player
  }
  strip.show(); //write to the screen
  Serial.begin (9600); //begin serial moniter
}

void loop() {
  delay(20); //20ms delay, not long enough to miss button inputs
  for (int i = 0; i < 2; i++) { //for both players
    if (props[i][1] == 0) { // if the direction changer is 0
      props[i][1] = readbut(buttons[i][0], buttons[i][1], i); //set the change in direction equal to the return of the players button readings
    }
  }
  if (millis() > timedraw) { //if statement to draw a single frame after a specified time
    checkfood(); //check if either player is on top of the food
    changedir(); //change the players direction based on the changedir property from the button inputs
    writecoords(); //shift the bodies down their arrays and write a new head coordinate by incrimenting the direction
    checkcolision(); //check if either player has colided with the other, or themselves
    eraseplayer(); //erase the players tail
    drawplayer(); //draw the players head
    if (needfood == 1) { //if a food is needed
      food = createfood(); //set food to a random spot generated by createfood
      needfood = 0; //food spawn is no longer needed
    }
    timedraw = timedraw + 225; //the time incriment do draw a frame
  }
}

int readbut(int rb , int lb, int l) { //used to translate button inputs into a direction incrimenter when given a player's button pins
  if (digitalRead(lb) == 0 && digitalRead(rb) == 0) { //if both buttons are depressed
    locks[l] = 0; //turn the button lock off
    return 0; //no change in direction
  }
  if (digitalRead(rb) != digitalRead(lb) && locks[l] == 0) { //if one button is pressed
    locks[l] = 1; //turn the button lock on 
    return (digitalRead(rb) - digitalRead(lb)); //return either a postive or negitave direction change based on the button readings
  }
  else { //if both buttons are pressed
    return 0; //no direction change
  }
}

void changedir() { //change the players direction based on the changedir property from the button inputs
  for (int i = 0; i < 2; i++) { //for both players
    if (props[i][1] != 0) { //if the direction changer is not 0
      props[i][0] = props[i][0] + props[i][1]; //add the direction changer to the direction
      if (props[i][0] < 0 || props[i][0] > 3) { //if the direction is outside one of the four directions
        props[i][0] = (((props[i][0] + 1) * (-3) / 5) + 3); //warp it back around
      }
      props[i][1] = 0; //set the direction changer to 0
    }
  }
}

void writecoords() { //shift the bodies down their arrays and write a new head coordinate by incrimenting the direction
  for (int i = 0; i < 2; i++) { //for both players
    for (int p = props[i][2]; p > 0; p--) { //for the length of the body (starting at the end) -- used the shift all segments down
      body[i][p][0] = body[i][p - 1][0]; //set the row coordinate to the previous coordinate
      body[i][p][1] = body[i][p - 1][1]; //set the column coordinate to the previous coordinate
    }
    for (int j = 0; j < 2; j++) { //for both the row and the column coordinate of the head of both snakes
      body[i][0][j] = (body[i][1][j] + (- abs(props[i][0] - 2 + j) + 1)); //incriment the head row based on the current direction
      if (body[i][0][j] > 7 || body[i][0][j] < 0) { //if both the row and the column coordinate are out of bounds
        body[i][0][j] = (((body[i][0][j] + 1) * (-7) / 9) + 7); //warp them around the screen (in bounds is (0 to 7), so -1 goes to 7 and 8 goes to 0)
      }
    }
  }
}

void checkcolision() { //check if either player has colided with the other, or themselves
  if (body[0][0][0] == body[1][0][0] && body[0][0][1] == body[1][0][1]) { //if both heads are occupying the same coordinates
    strip.setPixelColor(led[body[0][0][0] + body[0][0][1] * 8], 100, 0 , 150); //set the color to a mix of red and blue
    flipbodies(); //make the tail the into the head for both players
  }
  else { //if both heads are not on the same coordinates
    for (int i = 0; i < 2; i++) { //for both players
      for (int j = 1; j < props[abs(i - 1)][2]; j++) { //for the length minus one of the other player
        if ((body[i][0][0] == body[abs(i - 1)][j][0]) && (body[i][0][1] == body[abs(i - 1)][j][1])) { //if the players head is coliding with the others body
          end(2 - i); //the game is over, the opposite player to the one being checked wins (either 1 or 2)
        }
      }
      for (int k = 4; k < props[i][2]; k++) { // for the length of the given player, starting at the fifth segment
        if ((body[i][0][0] == body[i][k][0] && body[i][0][1] == body[i][k][1])) { // if the players head is coliding with its own body
          end(2 - i); //the game is over, the opposite player to the one being checked wins (either 1 or 2)
        }
      }
    }
  }
}

void drawplayer() { //draw the players head
  for (int i = 0; i < 2; i++) { //for both players
    strip.setPixelColor(led[body[i][0][0] + body[i][0][1] * 8], 100 - (100 * i), 0, 255 * i); //turn the head pixel on, with color based on the player
  }
  strip.show(); //print to the screen
}

void eraseplayer() { //erase the players tail
  for (int i = 0; i < 2; i++) { //for both players
    strip.setPixelColor(led[body[i][props[i][2]][0] + body[i][props[i][2]][1] * 8], 0, 0, 0); // set the last coordinate in the snake off (last coord = length)
  }
}

int createfood() { //generate a valid food placement
  int f = random(64); //generate a random number 0 - 63
  for (int i = 0; i < 2; i++) { //for both players
    for (int k = 0; k < props[i][2]; k++) { //for the players entie lengths
      if (f == body[i][k][0] + body[i][k][1] * 8) { //if the random number is the position of the body segment
        f = -1; //set f to invalid
        break; 
      }
    }
  }
  if (f == -1) { //if f is invalid
    createfood(); //recurse to find a valid random number
  }
  else { //if f is valid
    strip.setPixelColor(led[f], 100, 100, 100); //set the new food on with all colors (white)
    return f; //return the valid foods position
  }
}

void checkfood() { //check if either player is on the food
  for (int i = 0; i < 2; i++) { //for both players
    if ((body[i][0][0] + body[i][0][1] * 8) == food) { //if the head segment is on the food
      props[i][2]++; //incriment the length up
      needfood = 1; //a new food is needed
    }
  }
}
void flipbodies() { //make the tail into the head for both players (or else its a tie)
  for (int i = 0; i < 2; i++) { //for both players
    for (int j = 0; j < props[i][2]; j++) { //for the length of the player
      for (int k = 0; k < 2; k++) { //for both the row and column
        flipper[i][j][k] = body[i][j][k]; // set the flipper array to the body
      }
    }
    for (int j = 0; j < props[i][2]; j++) { //for the length of the player, again
      for (int k = 0; k < 2; k++) { //for both the row and the column, again
        body[i][j][k] = flipper[i][props[i][2] - 1 - j][k]; //set the first entry of the body to the last of the flipper, and incriment reverse to flip it
      }
    }
    int drow = body[i][1][0] - body[i][0][0]; //store the change in row from the new second to the new first coordinates
    int dcol = body[i][1][1] - body[i][0][1]; //store the change in column from the new second to the new first coordinates
    if (drow == 0) { //if there is no change in row
      if (dcol != 7 && dcol != -7) { //if the change in column does not wrap around the edge
        props[i][0] = (dcol + 2); //set the new direction based on the change in column (since there can only be either a row or collumn change, not both)
      }
      else { //if the change in column wraps around the edge
        props[i][0] = ((abs(dcol + 7) * (-1) / (7)) + 2); //set the new direction based on the change in column
      }
    }
    else { // if there is a change in row
      if (drow != 7 && drow != -7) { //if the change in rpw does not wrap around the edge
        props[i][0] = abs((drow) - 1); //set the new direction based on the change in row
      }
      else { //if the change in row does wrap around the edge
        props[i][0] = (drow / 7) + 1; ////set the new direction based on the change in row
      }
    }
  }
}

void end(int w) { //if the game is over, give a certian player the win and reset the board
  int i;
  digitalWrite( w * 12 - 12, HIGH); //set a players led on based on the input
  delay(1000); //preserve the board for a second
  int a = 200 - (100 * w); //set the color values for the color wipe based on the winner
  int b = (w * 100) - 100; //set the color values for the color wipe based on the winner
  for (i = 0; i < 64; i++) { // for all pixels
    strip.setPixelColor(i, a, 0, b); //set the color to the winners color
    strip.show(); //write to the screen 
    delay(10); //delay for 10 ms
  }
  delay(100); // delay 100 ms
  digitalWrite( w * 12 - 12, LOW); //turn the winners led off
  for (i = 0; i < 64; i++) { //for all pixels
    strip.setPixelColor(i, 0, 0, 0); //turn the input off
    strip.show(); //write to the screen
    delay(10); //delay 10ms
  }
  resetbodies(); //reset the bodies original position
  timedraw = millis() + 500; //time until first frame is drawn is .5s
  needfood = 1; //another food is needed
}


